% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/control_for_euc.R
\name{control_for_euc}
\alias{control_for_euc}
\title{Control for Euclidean distance in several numeric variables}
\usage{
control_for_euc(
  x,
  vars,
  tol,
  name = NA,
  scale = TRUE,
  center = TRUE,
  weights = NA,
  standardise_weights = TRUE,
  euc_df = NA,
  standard_eval = FALSE
)
}
\arguments{
\item{x}{A data frame containing the IV and strings, or a LexOPS_pipeline object resulting from one of \code{split_by()}, \code{control_for()}, etc..}

\item{vars}{The columns from which to calculate Euclidean distance.}

\item{tol}{The desired control tolerance, in Euclidean distance (will be interpreted as scaled Euclidean distance if \code{scaled == TRUE}).}

\item{name}{What the output column should be named. If \code{NA} (default), will automatically assign as \code{sprintf("control_fun_\%i", nr)}, where \code{nr} is the number of the control function.}

\item{scale, center}{How should variables be scaled and/or centred \emph{before} calculating Euclidean distance? For options, see the \code{scale} and \code{center} arguments of \code{\link[base]{scale}}. Default for both is \code{TRUE}. Scaling can be useful when variables are in differently scaled.}

\item{weights}{An (optional) list of weights, in the same order as \code{vars}. After any scaling is applied, the values will be multiplied by these weights. Default is \code{NA}, meaning all variables are weighted equally.}

\item{standardise_weights}{Logical; should the weights be standardised to average to 1 (i.e., sum to the length of \code{vars})? If TRUE, \code{weights=c(1, 3, 6)} will be treated as \code{weights=c(0.3, 0.6, 1.8)}. Setting \code{standardise_weights=TRUE} ensures that the space itself is unchanged when weights change. This means that the same tolerance can be used when the weights change.}

\item{euc_df}{The dataframe to calculate the Euclidean distance from. By default, the function will use \code{df}. Giving a different dataframe to \code{euc_df} can be useful in some cases, such as when \code{df} has been filtered for generating stimuli, but you want to calculate Euclidean Distance from a full distribution.}

\item{standard_eval}{Logical; bypasses non-standard evaluation, and allows more standard R objects in \code{vars} and \code{tol}. If \code{TRUE}, \code{vars} should be a character vector referring to columns in \code{df} (e.g. \code{c("Zipf.SUBTLEX_UK", "Length")}), and \code{tol} should be a vector of length 2, specifying the tolerance (e.g. \code{c(0, 0.5)}). Default = \code{FALSE}.}
}
\value{
Returns \code{df}, with details on the variables to be controlled for added to the attributes. Run the \code{\link{generate}} function to then generate the actual stimuli.
}
\description{
This function is a wrapper for \code{\link{control_for_map}} that allows you to easily control for Euclidean distance.
}
\examples{

stim <- lexops |>
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) |>
  control_for_euc(c(Zipf.BNC.Written, Length), 0:0.005) |>
  generate(10)

# bypass non-standard evaluation
stim <- lexops \%>\%
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) |>
  control_for_euc(c("Zipf.BNC.Written", "Length"), c(0, 0.005), standard_eval = TRUE) |>
  generate(10)

# generate stimuli from a filtered dataframe, but calculate
# Euclidean distance from an (original) unfiltered dataframe
library(dplyr)
stim <- lexops |>
  filter(
    Zipf.SUBTLEX_UK <= 5,
    between(Length, 3, 12),
    PK.Brysbaert >= 0.9
  ) |>
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) |>
  control_for_euc(
    c(Zipf.SUBTLEX_UK, Length),
    0:0.005,
    name = "Euclidean Distance",
    euc_df = lexops
  ) |>
  generate(10)

}
