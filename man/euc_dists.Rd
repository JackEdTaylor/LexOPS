% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/euc_dists.R
\name{euc_dists}
\alias{euc_dists}
\title{Calculate a word's Euclidean distance from other words}
\usage{
euc_dists(
  df = LexOPS::lexops,
  target,
  vars = "all",
  scale = TRUE,
  center = TRUE,
  weights = NA,
  standardise_weights = TRUE,
  id_col = "string",
  standard_eval = FALSE
)
}
\arguments{
\item{df}{A data frame.}

\item{target}{The target string (word) that euclidean distances are required for.}

\item{vars}{The variables to be used as dimensions which Euclidean distance should be calculated over. Can be a vector of variable names (e.g. \code{c(Zipf.SUBTLEX_UK, Length)}), or, \code{"all"}, to use all numeric variables in the data frame. The default is \code{"all"}.}

\item{scale, center}{How should variables be scaled and/or centred before calculating Euclidean distance? For options, see the \code{scale} and \code{center} arguments of \code{\link[base]{scale}}. Default for both is \code{TRUE}. Scaling can be useful when variables are in differently scaled.}

\item{weights}{An (optional) list of weights, in the same order as \code{vars}. After any scaling is applied, the values will be multiplied by these weights. Default is \code{NA}, meaning no weights are applied.}

\item{standardise_weights}{Logical; should the weights be standardised to average to 1 (i.e., sum to the length of \code{vars})? If TRUE, \code{weights=c(1, 3, 6)} will be treated as \code{weights=c(0.3, 0.6, 1.8)}. Setting \code{standardise_weights=TRUE} ensures that the space itself is unchanged when weights change. This means, for example, that the same tolerance can be used in \code{control_for_euc()}.}

\item{id_col}{The column containing the strings (default = \code{"string"}).}

\item{standard_eval}{Logical; bypasses non-standard evaluation, and allows more standard R objects in \code{vars}. If \code{TRUE}, \code{vars} should be a character vector referring to columns in \code{df} (e.g. \code{c("Length", "Zipf.SUBTLEX_UK")}). Default = \code{FALSE}.}
}
\value{
Returns a vector of Euclidean distances, in the order of rows in \code{df}.
}
\description{
Caclulates the Euclidean distance of a word from all other words in a df, on selected variables.
}
\examples{

# Get the distance of every entry in the `lexops` dataset from the word "thicket".
# (Note: This will be calculated using the dimensions of frequency, arousal, and size)
lexops |>
  euc_dists("thicket", c(Zipf.SUBTLEX_UK, AROU.Warriner, SIZE.Glasgow_Norms))

# no scaling or centering
lexops |>
  euc_dists(
    "thicket",
    c(Zipf.SUBTLEX_UK, AROU.Warriner, SIZE.Glasgow_Norms),
    scale = FALSE,
    center = FALSE
  )

# Add Euclidean distance as new column
# (Also sort ascendingly by distance; barbara will have a distance of 0 so will be first)
lexops \%>\%
  dplyr::mutate(ed = euc_dists(., "barbara", c(Length, Zipf.SUBTLEX_UK, BG.SUBTLEX_UK))) |>
  dplyr::arrange(ed)

# bypass non-standard evaluation
lexops |>
  euc_dists(
    "thicket",
    c("Zipf.SUBTLEX_UK", "AROU.Warriner", "SIZE.Glasgow_Norms"),
    standard_eval = TRUE
  )
}
