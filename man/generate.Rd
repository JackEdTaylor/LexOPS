% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate.R
\name{generate}
\alias{generate}
\title{Generate stimuli}
\usage{
generate(
  df,
  n = 20,
  match_null = "balanced",
  seed = NA,
  silent = FALSE,
  is_shiny = FALSE
)
}
\arguments{
\item{df}{A data frame that is the result from \code{control_for()} or \code{split_by()}.}

\item{n}{The number of strings per condition (default = 20). Set to \code{"all"} to generate as many as possible.}

\item{match_null}{The condition words should be matched to. Should be a string indicating condition (e.g. \code{"A1_B2_C1"}), or a string indicating one of the following options: "first" for the lowest condition (e.g. \code{"A1"} or \code{"A1_B1_C1_D1"}, etc.), "random" for randomly selected null condition each iteration, "balanced" for randomly ordered null conditions with (as close to as possible) equal number of selections for each condition.}

\item{seed}{An integer specifying the random seed, allowing reproduction of exact stimuli lists. If \code{NA}, will not set the seed. Default is \code{NA}.}

\item{silent}{Logical: should output to the console (via \code{cat()}) be suppressed? Default is FALSE.}

\item{is_shiny}{Allows printing in a shiny context with \code{shinyjs::html()}. Outputs from the cat() function are stored in the div with id "gen_console". Default is FALSE.}
}
\value{
Returns the generated stimuli.
}
\description{
Generates the stimuli from the data frame after it has been passed through \code{split_by()}, and optionally, \code{control_for()}. Will generate \code{n} items per condition. If <\code{n} items can be generated, will generate as many as possible given the experiment's design. Can be reproducible with \code{set.seed()}.
}
\examples{

# Generate 20 words per condition, for design with 3 levels of syllables, controlled for frequency
lexops \%>\%
  split_by(Syllables.CMU, 1:3 ~ 4:6 ~ 7:20) \%>\%
  control_for(Zipf.SUBTLEX_UK, -0.2:0.2) \%>\%
  generate(n = 20)

# Generate 2 levels of bigram probability, controlling for frequency and length
# (Note that the matching null is balanced across all stimuli)
# (Also note that the data is filtered by proportion known to be >75\%)
lexops \%>\%
  dplyr::filter(PK.Brysbaert >= .75) \%>\%
  split_by(BG.SUBTLEX_UK, 0.001:0.003 ~ 0.009:0.011) \%>\%
  control_for(Zipf.SUBTLEX_UK, -0.2:0.2) \%>\%
  control_for(Length) \%>\%
  generate(n = 1000, match_null = "balanced")

# Generate stimuli for a concreteness x valence (2 x 3) design
# (Note that abstract, neutral is set as the matching null)
lexops \%>\%
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) \%>\%
  split_by(VAL.Warriner, 1:3 ~ 4.5:5.5 ~ 7:9) \%>\%
  control_for(Zipf.SUBTLEX_UK, -0.25:0.25) \%>\%
  control_for(Length) \%>\%
  generate(n = 30, match_null = "A2_B2")

# As above but with inclusive tolerance
# (all words are within the specified tolerances relative to each other)
lexops \%>\%
  split_by(CNC.Brysbaert, 1:2 ~ 4:5) \%>\%
  split_by(VAL.Warriner, 1:3 ~ 4.5:5.5 ~ 7:9) \%>\%
  control_for(Zipf.SUBTLEX_UK, -0.25:0.25) \%>\%
  control_for(Length) \%>\%
  generate(n = 30, match_null = "inclusive")

# Bypass non-standard evaluation
lexops \%>\%
 split_by("Syllables.CMU", list(c(1, 3), c(4, 6), c(7, 20)), standard_eval = TRUE) \%>\%
 control_for("Zipf.SUBTLEX_UK", c(-0.2, 0.2), standard_eval = TRUE) \%>\%
 generate(n = 20)

# Create two levels of arousal, controlling for orthographic similarity
library(vwr)
lexops \%>\%
 split_by(AROU.Warriner, 1:3 ~ 6:9) \%>\%
 control_for_map(levenshtein.distance, string, 0:4) \%>\%
 generate(20)

# Create two levels of arousal, controlling for phonological similarity
library(vwr)
lexops \%>\%
 split_by(AROU.Warriner, 1:3 ~ 6:9) \%>\%
 control_for_map(levenshtein.distance, eSpeak.br_1letter, 0:2) \%>\%
 generate(20)

# Create two levels of arousal, controlling for phonological similarity, and rhyme
library(vwr)
lexops \%>\%
 split_by(AROU.Warriner, 1:3 ~ 6:9) \%>\%
 control_for(Rhyme.eSpeak.br) \%>\%
 control_for_map(levenshtein.distance, eSpeak.br_1letter, 0:2) \%>\%
 generate(20)

# A similar design to that above, but with 3 levels of valence, and inclusive matching
# Note that this will result in exactly the same result as above.
# A function that calculates something like Semantic Similarity will produce very different results.
library(vwr)
lexops \%>\%
 split_by(VAL.Warriner, 1:3 ~ 4.5:5.5 ~ 7:9) \%>\%
 control_for(Rhyme.eSpeak.br) \%>\%
 control_for_map(levenshtein.distance, eSpeak.br_1letter, 0:2) \%>\%
 generate(20, match_null = "inclusive")

}
